dataset = dataset_wrapper.groups_from_ids
    separator = "^"

    dataset = dataset_wrapper.cached
        dataset = dataset_wrapper.normalized
            mean = true
            std = true
            drop_percentile = null

            dataset = dataset_wrapper.bbox_extraction
                dataset = dataset_wrapper.merge_datasets
                    datasets = [
                        dataset.brats2017(data_path = "/some/path")
                        dataset.brats2017(
                                data_path = "/some/other/path"
                                metadata_rpath = "meta_approved.csv"
                        )]

train_ids = meta.from_json
    path = train_ids_path
val_ids = meta.from_json
    path = val_ids_path
ids = meta.from_json
    path = ids_path

experiment = experiment.flat
    makefile = "train_segm_evaluate"
    config_path = config_path
    experiment_path = experiment_path
    split = split.group_pure_val_test_cv_111
        n_splits = 5
        val_size = 6
        dataset = dataset

load_x = meta.extractor
    property = "load_mscan"
    module = dataset

load_y = meta.extractor
    property = "load_segm"
    module = dataset

batch_iter_factory = batch_iter_factory.inf
    n_iters_per_batch = 200

    get_batch_iter = batch_iter.patch_strat_3d
        @init = false
        batch_size = 64
        x_patch_sizes = [[25, 25, 25], [57, 57, 57]]
        y_patch_size = [9, 9, 9]
        nonzero_fraction = 0.5
        buffer_size = 10
        ids = train_ids
        load_x = load_x
        load_y = load_y

model_core = model_core.deepmedic_els
    n_parts = [1 1 1]
    with_dropout = false
    downsampling_type = "sampling"
    n_chans_in = meta.extractor
        property = "n_chans_mscan"
        module = dataset

    n_chans_out = meta.extractor
        property = "n_chans_segm"
        module = dataset

predict = predict.softmax
    @init = false

model = model.model
    model_core = model_core
    predict = predict
    loss = loss.sparse_softmax_cross_entropy
        @init = false

    optimize = optimize.tf_optimize
        @init = false
        tf_optimizer_name = "MomentumOptimizer"
        use_nesterov = true
        momentum = 0.9

frozen_model = model.frozen_model
    model_core = model_core
    predict = predict

model_controller = model_controller.model_controller
    model = model
    log_path = log_path

train = train.train_segm
    @init = false

    n_epochs = 120
    lr_init = 0.1
    lr_dec_mul = 0.5
    patience = 5
    rtol = 0.03
    atol = 0.01
    model_controller = model_controller
    train_batch_iter_factory = batch_iter_factory
    val_ids = val_ids
    dataset = dataset

pred2msegm = transform.segm_prob2msegm
    @init = false
    dataset = dataset


:becomes:


{
  "dataset": {
    "type": "dataset_wrapper",
    "name": "groups_from_ids",
    "params": {"separator": "^"},
    "inputs": {
      "dataset": {
        "type": "dataset_wrapper",
        "name": "cached",
        "inputs": {
          "dataset": {
            "type": "dataset_wrapper",
            "name": "normalized",
            "params": {"mean": true, "std": true, "drop_percentile": null},
            "inputs": {
              "dataset": {
                "type": "dataset_wrapper",
                "name": "bbox_extraction",
                "inputs": {
                  "dataset": {
                    "type": "dataset_wrapper",
                    "name": "merge_datasets",
                    "inputs": {
                      "datasets": [
                        {
                          "type": "dataset",
                          "name": "brats2017",
                          "params": {"data_path": "/some/path"}
                        },
                        {
                          "type": "dataset",
                          "name": "brats2017",
                          "params": {
                            "data_path": "/some/other/path",
                            "metadata_rpath": "meta_approved.csv"
                          }
                        }
                      ]
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },

  "train_ids": {
    "type": "meta",
    "name": "from_json",
    "inputs": {"path": "train_ids_path"}
  },

  "val_ids": {
    "type": "meta",
    "name": "from_json",
    "inputs": {"path": "val_ids_path"}
  },

   "ids": {
    "type": "meta",
    "name": "from_json",
    "inputs": {"path": "ids_path"}
  },

  "experiment": {
    "type": "experiment",
    "name": "flat",
    "params": {"makefile": "train_segm_evaluate"},
    "inputs": {
      "config_path": "config_path",
      "experiment_path": "experiment_path",
      "split": {
        "type": "split",
        "name": "group_pure_val_test_cv_111",
        "params": {
          "n_splits": 5,
          "val_size": 6
        },
        "inputs": {"dataset": "dataset"}
      }
    }
  },

  "load_x": {
    "type": "meta",
    "name": "extractor",
    "params": {"property": "load_mscan"},
    "inputs": {"module": "dataset"}
  },

  "load_y": {
    "type": "meta",
    "name": "extractor",
    "params": {"property": "load_segm"},
    "inputs": {"module": "dataset"}
  },

  "batch_iter_factory": {
    "type": "batch_iter_factory",
    "name": "inf",
    "params": {"n_iters_per_batch": 200},
    "inputs": {
      "get_batch_iter": {
        "type": "batch_iter",
        "name": "patch_strat_3d",
        "init": false,
        "params": {
          "batch_size": 64,
          "x_patch_sizes": [[25, 25, 25], [57, 57, 57]],
          "y_patch_size": [9, 9, 9],
          "nonzero_fraction": 0.5,
          "buffer_size": 10
        },
        "inputs": {
          "ids": "train_ids",
          "load_x": "load_x",
          "load_y": "load_y"
        }
      }
    }
  },

  "model_core": {
    "type": "model_core",
    "name": "deepmedic_els",
    "params": {"n_parts": [1, 1, 1], "with_dropout": false, "downsampling_type": "sampling"},
    "inputs": {
      "n_chans_in": {
        "type": "meta",
        "name": "extractor",
        "params": {"property": "n_chans_mscan"},
        "inputs": {"module": "dataset"}
      },
      "n_chans_out": {
        "type": "meta",
        "name": "extractor",
        "params": {"property": "n_chans_segm"},
        "inputs": {"module": "dataset"}
      }
    }
  },

  "predict": {"type": "predict", "name": "softmax", "init": false},

  "model": {
    "type": "model",
    "name": "model",
    "inputs": {
      "model_core": "model_core",
      "predict": "predict",
      "loss": {
        "name": "sparse_softmax_cross_entropy",
        "type": "loss",
        "init": false
      },
      "optimize": {
        "type": "optimize",
        "name": "tf_optimize",
        "params": {
          "tf_optimizer_name": "MomentumOptimizer",
          "use_nesterov": true,
          "momentum": 0.9
        },
        "init": false
      }
    }
  },

  "frozen_model": {
    "type": "model",
    "name": "frozen_model",
    "inputs": {
      "model_core": "model_core",
      "predict": "predict"
    }
  },

  "model_controller": {
    "type": "model_controller",
    "name": "model_controller",
    "inputs": {"model": "model", "log_path": "log_path"}
  },

  "train": {
    "type": "train",
    "name": "train_segm",
    "params": {
      "n_epochs": 120,
      "lr_init": 0.1,
      "lr_dec_mul": 0.5,
      "patience": 5,
      "rtol": 0.03,
      "atol": 0.01
    },
    "inputs": {
      "model_controller": "model_controller",
      "train_batch_iter_factory": "batch_iter_factory",
      "val_ids": "val_ids",
      "dataset": "dataset"
    },
    "init": false
  },

  "pred2msegm": {
    "type": "transform",
    "name": "segm_prob2msegm",
    "inputs": {"dataset": "dataset"},
    "init": false
  }
}
